package scraper.parsers

import scala.collection.mutable

import fastparse.all._

// SQL06 section 5.2
object KeywordParser {
  private val reservedWords: mutable.ArrayBuffer[P0] = mutable.ArrayBuffer.empty[P0]

  private def mkKeyword(literal: String): P0 = {
    val parser = IgnoreCase(literal) opaque literal.toUpperCase
    reservedWords += parser
    parser
  }

  val ALL: P0 = mkKeyword("ALL")
  val AND: P0 = mkKeyword("AND")
  val ARRAY: P0 = mkKeyword("ARRAY")
  val AS: P0 = mkKeyword("AS")
  val ASC: P0 = mkKeyword("ASC")
  val BETWEEN: P0 = mkKeyword("BETWEEN")
  val BIGINT: P0 = mkKeyword("BIGINT")
  val BINARY: P0 = mkKeyword("BINARY")
  val BLOB: P0 = mkKeyword("BLOB")
  val BOOLEAN: P0 = mkKeyword("BOOLEAN")
  val BY: P0 = mkKeyword("BY")
  val CASE: P0 = mkKeyword("CASE")
  val CAST: P0 = mkKeyword("CAST")
  val COALESCE: P0 = mkKeyword("COALESCE")
  val CROSS: P0 = mkKeyword("CROSS")
  val CURRENT: P0 = mkKeyword("CURRENT")
  val DATE: P0 = mkKeyword("DATE")
  val DAY: P0 = mkKeyword("DAY")
  val DEC: P0 = mkKeyword("DEC")
  val DECIMAL: P0 = mkKeyword("DECIMAL")
  val DESC: P0 = mkKeyword("DESC")
  val DISTINCT: P0 = mkKeyword("DISTINCT")
  val DOUBLE: P0 = mkKeyword("DOUBLE")
  val ELSE: P0 = mkKeyword("ELSE")
  val END: P0 = mkKeyword("END")
  val EXCEPT: P0 = mkKeyword("EXCEPT")
  val FALSE: P0 = mkKeyword("FALSE")
  val FIRST: P0 = mkKeyword("FIRST")
  val FLOAT: P0 = mkKeyword("FLOAT")
  val FOLLOWING: P0 = mkKeyword("FOLLOWING")
  val FROM: P0 = mkKeyword("FROM")
  val FULL: P0 = mkKeyword("FULL")
  val GROUP: P0 = mkKeyword("GROUP")
  val HAVING: P0 = mkKeyword("HAVING")
  val HOUR: P0 = mkKeyword("HOUR")
  val IF: P0 = mkKeyword("IF")
  val INNER: P0 = mkKeyword("INNER")
  val INT: P0 = mkKeyword("INT")
  val INTEGER: P0 = mkKeyword("INTEGER")
  val INTERSECT: P0 = mkKeyword("INTERSECT")
  val INTERVAL: P0 = mkKeyword("INTERVAL")
  val IS: P0 = mkKeyword("IS")
  val JOIN: P0 = mkKeyword("JOIN")
  val LARGE: P0 = mkKeyword("LARGE")
  val LAST: P0 = mkKeyword("LAST")
  val LEFT: P0 = mkKeyword("LEFT")
  val LIMIT: P0 = mkKeyword("LIMIT")
  val MAP: P0 = mkKeyword("MAP")
  val MINUTE: P0 = mkKeyword("MINUTE")
  val MODULE: P0 = mkKeyword("MODULE")
  val MONTH: P0 = mkKeyword("MONTH")
  val NATURAL: P0 = mkKeyword("NATURAL")
  val NOT: P0 = mkKeyword("NOT")
  val NULL: P0 = mkKeyword("NULL")
  val NULLIF: P0 = mkKeyword("NULLIF")
  val NULLS: P0 = mkKeyword("NULLS")
  val NUMERIC: P0 = mkKeyword("NUMERIC")
  val OBJECT: P0 = mkKeyword("OBJECT")
  val ON: P0 = mkKeyword("ON")
  val ORDER: P0 = mkKeyword("ORDER")
  val OR: P0 = !ORDER ~ mkKeyword("OR")
  val OUTER: P0 = mkKeyword("OUTER")
  val OVER: P0 = mkKeyword("OVER")
  val PARTITION: P0 = mkKeyword("PARTITION")
  val PRECEDING: P0 = mkKeyword("PRECEDING")
  val PRECISION: P0 = mkKeyword("PRECISION")
  val RANGE: P0 = mkKeyword("RANGE")
  val REAL: P0 = mkKeyword("REAL")
  val RIGHT: P0 = mkKeyword("RIGHT")
  val ROW: P0 = mkKeyword("ROW")
  val ROWS: P0 = mkKeyword("ROWS")
  val SECOND: P0 = mkKeyword("SECOND")
  val SELECT: P0 = mkKeyword("SELECT")
  val SMALLINT: P0 = mkKeyword("SMALLINT")
  val STRING: P0 = mkKeyword("STRING")
  val STRUCT: P0 = mkKeyword("STRUCT")
  val THEN: P0 = mkKeyword("THEN")
  val TIME: P0 = mkKeyword("TIME")
  val TIMESTAMP: P0 = mkKeyword("TIMESTAMP")
  val TINYINT: P0 = mkKeyword("TINYINT")
  val TO: P0 = mkKeyword("TO")
  val TRUE: P0 = mkKeyword("TRUE")
  val UESCAPE: P0 = mkKeyword("UESCAPE")
  val UNBOUNDED: P0 = mkKeyword("UNBOUNDED")
  val UNION: P0 = mkKeyword("UNION")
  val UNKNOWN: P0 = mkKeyword("UNKNOWN")
  val WHEN: P0 = mkKeyword("WHEN")
  val WHERE: P0 = mkKeyword("WHERE")
  val WINDOW: P0 = mkKeyword("WINDOW")
  val WITH: P0 = mkKeyword("WITH")
  val WITHOUT: P0 = mkKeyword("WITHOUT")
  val YEAR: P0 = mkKeyword("YEAR")
  val ZONE: P0 = mkKeyword("ZONE")

  val keyword: P0 = reservedWords reduce { _ | _ } opaque "keyword"
}
